// A stub for a Xi CUP specification.

package jl2755;

/* Terminals */
terminal java.lang.String IDENTIFIER;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.Integer INTEGER_LITERAL;
terminal java.lang.Boolean TRUE, FALSE;
terminal java_cup.runtime.Symbol INT, BOOL;
// keywords
terminal IF, ELSE, WHILE, RETURN, USE, PLUS, MINUS, TIMES, HIGH_MULT,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, LENGTH;

/* Nonterminals */
// You might want to add types to these declarations.
nonterminal program;
// Add more nonterminals here...
nonterminal var_init;
nonterminal var_decl;
nonterminal tuple_init;
nonterminal tuple_decl_list;
nonterminal type;
nonterminal type_list;
nonterminal return_type;
nonterminal primitive_type;
nonterminal array_type;
nonterminal brackets;
nonterminal brackets_with_content;
nonterminal expr;
nonterminal constant;
nonterminal unary_expr;
nonterminal binary_expr;
nonterminal binary_op;
nonterminal literal;
nonterminal use_id;
nonterminal function_param;
nonterminal function_decl;
nonterminal function_decl_list;
nonterminal function_call;
nonterminal function_arg;
nonterminal array_literal;
nonterminal array_element_list;
nonterminal array_element;
nonterminal stmt;
nonterminal assignment_stmt;
nonterminal if_stmt;
nonterminal while_stmt;
nonterminal return_stmt;
nonterminal block_stmt;
nonterminal stmt_list;
nonterminal return_list;


/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL;
precedence left LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS; 
precedence left TIMES, HIGH_MULT, DIVIDE, MODULO;
precedence nonassoc ELSE;     // to avoid "dangling else" problem
// missing integer and logical negation (unary minus vs. binary minus)
precedence left OPEN_BRACKET, OPEN_PAREN;  // missing function call, []


start with program;

/* Grammar */
var_decl ::= IDENTIFIER COLON type ;

var_init ::= var_decl GETS expr ;

tuple_init ::= UNDERSCORE tuple_decl_list GETS function_call
               |
               var_decl tuple_decl_list GETS function_call
               |
               UNDERSCORE GETS function_call
               ;

tuple_decl_list ::= COMMA var_decl
          |
          COMMA var_decl tuple_decl_list
          |
          COMMA UNDERSCORE
          |
          COMMA UNDERSCORE tuple_decl_list
          ;

type ::= primitive_type 
         | 
         array_type ;

primitive_type ::= INT  {: RESULT = new PrimitiveType(INT)}
                   | 
                   BOOL {: RESULT = new PrimitiveType(BOOL)}
                   ;
 
array_type ::= primitive_type brackets
               |
               primitive_type brackets_with_content
               |
               primitive_type brackets_with_content brackets
               ;

brackets ::= OPEN_BRACKET CLOSE_BRACKET 
             | 
             OPEN_BRACKET CLOSE_BRACKET brackets 
             ;

brackets_with_content ::= OPEN_BRACKET expr CLOSE_BRACKET 
                          |
                          OPEN_BRACKET expr CLOSE_BRACKET brackets_with_content
                          ;

expr ::= constant
         |
         unary_expr
         |
         binary_expr
         |
         IDENTIFIER
         |
         array_element
         |
         function_call
         |
         OPEN_PAREN expr CLOSE_PAREN
         ;

constant ::= literal | array_literal ;

unary_expr ::= MINUS expr
               |
               NOT expr
               ;

binary_expr ::= expr binary_op expr ;

binary_op ::= PLUS | MINUS | TIMES | HIGH_MULT | DIVIDE | MODULO
              |
              EQUAL | NOT_EQUAL | LT | LEQ | GT | GEQ
              |
              AND | OR
              ;

literal ::= INTEGER_LITERAL
            |
            CHARACTER_LITERAL
            |
            STRING_LITERAL
            |
            TRUE | FALSE
            ;

function_call ::= IDENTIFIER OPEN_PAREN function_arg CLOSE_PAREN
                  |
                  IDENTIFIER OPEN_PAREN CLOSE_PAREN
                  ;

function_arg ::= expr
                 |
                 expr COMMA function_arg
                 ;

array_literal ::= OPEN_BRACE array_element_list CLOSE_BRACE ;

array_element_list ::= expr
                       |
                       expr COMMA array_element_list
                       |
                       ;

array_element ::= IDENTIFIER brackets_with_content ;

stmt ::= naked_stmt SEMICOLON | naked_stmt ;

naked_stmt ::= assignment_stmt
               |
               if_stmt
               |
               while_stmt
               |
               function_call
               |
               block_stmt
               |
               var_decl | var_init | tuple_init
               ;

assignment_stmt ::= IDENTIFIER GETS expr 
                    |
                    array_element GETS expr
                    ;

if_stmt ::= IF OPEN_PAREN expr CLOSE_PAREN stmt
            |
            IF OPEN_PAREN expr CLOSE_PAREN stmt ELSE stmt
            ;

while_stmt ::= WHILE OPEN_PAREN expr CLOSE_PAREN stmt ;

return_stmt ::= RETURN 
                |
                RETURN return_list
                ;

return_list ::= expr
                |
                expr COMMA return_list
                ;

function_decl ::= IDENTIFIER OPEN_PAREN function_param CLOSE_PAREN return_type block_stmt;

return_type ::= COLON type_list 
                | 

                ;

type_list ::= type | type COMMA type_list ;

function_decl_list ::= function_decl function_decl_list 
                       |                       
                       
                       ;

function_param ::= var_decl
                   |
                   var_decl COMMA function_param 
                   ;

block_stmt ::= OPEN_BRACE CLOSE_BRACE
               |
               OPEN_BRACE stmt_list CLOSE_BRACE
               |
               OPEN_BRACE stmt_list return_stmt CLOSE_BRACE
               ;

stmt_list ::= stmt
              |
              stmt stmt_list
              ;

use_id ::= USE IDENTIFIER
           |  
           USE IDENTIFIER SEMICOLON
           |
           USE IDENTIFIER use_id
           |
           USE IDENTIFIER SEMICOLON use_id
           ;

program ::= function_decl_list
            |
            use_id function_decl_list
            ;
