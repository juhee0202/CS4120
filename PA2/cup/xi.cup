// A stub for a Xi CUP specification.

package jl2755;

/* Terminals */
terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal Character CHARACTER_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Boolean TRUE, FALSE;
// keywords
terminal IF, ELSE, WHILE, RETURN, USE, PLUS, MINUS, UMINUS, TIMES, HIGH_MULT, INT, BOOL,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, LENGTH;

/* Nonterminals */
// You might want to add types to these declarations.
nonterminal Program program;
// Add more nonterminals here...
nonterminal VarInit var_init;
nonterminal VarDecl var_decl;
nonterminal TupleInit tuple_init;
nonterminal TupleDeclList tuple_decl_list;
nonterminal Type type;
nonterminal TypeList type_list;
nonterminal ReturnType return_type;
nonterminal PrimitiveType primitive_type;
nonterminal ArrayType array_type;
nonterminal Brackets brackets;
nonterminal BracketsWithContent brackets_with_content;
nonterminal Expr expr;
nonterminal Constant constant;
nonterminal UnaryExpr unary_expr;
nonterminal UnaryOp unary_op;
nonterminal BinaryExpr binary_expr;
nonterminal BinaryOp binary_op;
nonterminal Literal literal;
nonterminal UseId use_id;
nonterminal FunctionParam function_param;
nonterminal FunctionDecl function_decl;
nonterminal FunctionDeclList function_decl_list;
nonterminal FunctionCall function_call;
nonterminal FunctionArg function_arg;
nonterminal ArrayLiteral array_literal;
nonterminal ArrayElementList array_element_list;
nonterminal ArrayElement array_element;
nonterminal NakedStmt naked_stmt;
nonterminal Stmt stmt;
nonterminal AssignmentStmt assignment_stmt;
nonterminal IfStmt if_stmt;
nonterminal WhileStmt while_stmt;
nonterminal ReturnStmt return_stmt;
nonterminal BlockStmt block_stmt;
nonterminal StmtList stmt_list;
nonterminal ReturnList return_list;


/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL;
precedence left LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS; 
precedence left TIMES, HIGH_MULT, DIVIDE, MODULO;
precedence left UMINUS;
precedence nonassoc ELSE;     // to avoid "dangling else" problem
precedence nonassoc SEMICOLON;
// missing integer and logical negation (unary minus vs. binary minus)

precedence left OPEN_BRACKET, OPEN_PAREN;  // missing function call, []


start with program;

/* Grammar */
var_decl ::= IDENTIFIER:id COLON type:t                              {: RESULT = new VarDecl(id, t); :}
            ;

var_init ::= var_decl:vd GETS expr:expression                        {: RESULT = new VarInit(vd, expression); :}
             ;

tuple_init ::= UNDERSCORE tuple_decl_list:tdl GETS function_call:fc  {: RESULT = new TupleInit(tdl, fc); :}
           |
           var_decl:vd tuple_decl_list:tdl GETS function_call:fc     {: RESULT = new TupleInit(vd, tdl, fc); :}
           |
           UNDERSCORE GETS function_call:fc                          {: RESULT = new TupleInit(fc); :}
           ;

tuple_decl_list ::= COMMA var_decl:vd                                {: RESULT = new TupleDeclList(vd, false); :}
          |
          COMMA var_decl:vd tuple_decl_list:tdl                      {: RESULT = new TupleDeclList(vd, tdl, false); :}
          |
          COMMA UNDERSCORE                                           {: RESULT = new TupleDeclList(true); :}
          |
          COMMA UNDERSCORE tuple_decl_list:tdl                       {: RESULT = new TupleDeclList(tdl, true); :}
          ;

type ::= primitive_type:pt                                           {: RESULT = pt; :}
         | 
         array_type:at                                               {: RESULT = at; :}
         ;

primitive_type ::= INT                                               {: RESULT = new PrimitiveType(INT); :}         
                   | 
                   BOOL                                              {: RESULT = new PrimitiveType(BOOL); :}
                   ;

array_type ::= primitive_type:pt brackets:b                          {: RETURN = new ArrayType(pt, br); :}
               |
               primitive_type:pt brackets_with_content:bwc           {: RETURN = new ArrayType(pt, bwc); :}
               |
               primitive_type:pt brackets_with_content:bwc brackets:b{: RETURN = new ArrayType(pt, bwc, b); :}
               ;

brackets ::= OPEN_BRACKET CLOSE_BRACKET                              {: RETURN = new Brackets(); :}
             | 
             OPEN_BRACKET CLOSE_BRACKET brackets:b                   {: RETURN = new Brackets(b); :}
             ;

brackets_with_content ::= OPEN_BRACKET expr:e CLOSE_BRACKET          {: RETURN = new BracketsWithContent(e); :}
                       |
                       OPEN_BRACKET expr:e CLOSE_BRACKET brackets_with_content:bwc  {: RETURN = new BracketsWithContent(e, bwc); :}
                       ;

expr ::= constant:c                                                  {: RETURN = c; :}
         |
         unary_expr:ue                                               {: RETURN = ue; :}
         |
         binary_expr:be                                              {: RETURN = be; :}
         |
         IDENTIFIER:id                                               {: RETURN = id; :}
         |
         array_element:ae                                            {: RETURN = ae; :}
         |
         function_call:fc                                            {: RETURN = fc; :}
         |
         OPEN_PAREN expr:expression CLOSE_PAREN                      {: RETURN = expression; :}
         ;

constant ::= literal:l                                               {: RETURN = l; :}
             | 
             array_literal:al                                        {: RETURN = al; :}
             ;

unary_expr ::= unary_op:uo expr:expression                           {: RETURN = new UnaryExpr(expression, uo); :}
               ;

unary_op :: = MINUS                                                  {: RETURN = UnaryOp.INT_NEG; :} %prec UMINUS  
              |
              NOT                                                    {: RETURN = UnaryOp.NOT; :}
              ;

binary_expr ::= expr:e1 binary_op:op expr:e2                         {: RETURN = new BinaryExpr(e1, e2, op); :}
                ;

binary_op ::= PLUS                                                   {: RETURN = BinaryOp.PLUS; :}
              | MINUS                                                {: RETURN = BinaryOp.MINUS; :}
              | TIMES                                                {: RETURN = BinaryOp.TIMES; :}
              | HIGH_MULT                                            {: RETURN = BinaryOp.HIGH_MULT; :}
              | DIVIDE                                               {: RETURN = BinaryOp.DIVIDE; :}
              | MODULO                                               {: RETURN = BinaryOp.MODULO; :}
              | EQUAL                                                {: RETURN = BinaryOp.EQUAL; :}
              | NOT_EQUAL                                            {: RETURN = BinaryOp.NOT_EQUAL; :}
              | LT                                                   {: RETURN = BinaryOp.LT; :}
              | LEQ                                                  {: RETURN = BinaryOp.LEQ; :}
              | GT                                                   {: RETURN = BinaryOp.GT; :}
              | GEQ                                                  {: RETURN = BinaryOp.GEQ; :}
              | AND                                                  {: RETURN = BinaryOp.AND; :}
              | OR                                                   {: RETURN = BinaryOp.OR; :}
              ;

literal ::= INTEGER_LITERAL:il                                       {: RETURN = new Literal(il); :}
            |
            CHARACTER_LITERAL:cl                                     {: RETURN = new Literal(cl); :}
            |
            STRING_LITERAL:sl                                        {: RETURN = new Literal(sl); :}
            |
            TRUE                                                     {: RETURN = new Literal(true); :}
            | 
            FALSE                                                    {: RETURN = new Literal(false); :}
            ;

function_call ::= IDENTIFIER:id OPEN_PAREN function_arg:fa CLOSE_PAREN    {: RETURN = new FunctionCall(id, fa); :}
                  |
                  IDENTIFIER:id OPEN_PAREN CLOSE_PAREN                    {: RETURN = new FunctionCall(id); :}
                  ;

function_arg ::= expr:expression                                    {: RETURN = new FunctionArg(expression); :}
                 |
                 expr:expression COMMA function_arg:fa              { :RETURN = new Function(expression, fa); :}
                 ;

array_literal ::= OPEN_BRACE array_element_list:ael CLOSE_BRACE     {: RETURN = new ArrayLiteral(ael); :}
                  ;

array_element_list ::= expr:expression                              {: RETURN = new ArrayElementList(expression); :}
                       |
                       expr:expression COMMA array_element_list:ael {: RETURN = new ArrayElementList(expression,ael); :}
                       |
                                                                    {: RETURN = null; :}
                       ;

array_element ::= IDENTIFIER:id brackets_with_content:bwc           {: RETURN = new ArrayElement(id, bwc); :}
                  ;

stmt ::= naked_stmt:ns SEMICOLON                                    {: RETURN = new Stmt(ns, true); :}
         |
         naked_stmt:ns                                              {: RETURN = new Stmt(ns, false); :}
         ;

naked_stmt ::= assignment_stmt:ass                                  {: RETURN = ass; :}
         |
         if_stmt:is                                                 {: RETURN = is; :}
         |
         while_stmt:ws                                              {: RETURN = ws; :}
         |
         function_call:fc                                           {: RETURN = fc; :}
         |
         block_stmt:bs                                              {: RETURN = bs; :}
         |
         var_decl:vd                                                {: RETURN = vd; :}
         | 
         var_init:vi                                                {: RETURN = vi; :}
         | 
         tuple_init:ti                                              {: RETURN = ti; :}
         ;

assignment_stmt ::= IDENTIFIER:id GETS expr:expression              {: RETURN = new AssignmentStmt(id, expression); :}
                    |
                    array_element:ae GETS expr:expression           {: RETURN = new AssignmentStmt(ae, expression); :}
                    ;

if_stmt ::= IF OPEN_PAREN expr:e CLOSE_PAREN stmt:s                 {: RETURN = new IfStmt(e, s); :}
            | 
            IF OPEN_PAREN expr:e CLOSE_PAREN stmt:s1 ELSE stmt:s2   {: RETURN = new IfStmt(e, s1, s2); :}
            ;

while_stmt ::= WHILE OPEN_PAREN expr:expression CLOSE_PAREN stmt:s  {: RETURN = new WhileStmt(expression, s); :}

return_stmt ::= RETURN                                              {: RETURN = new ReturnStmt(); :}
                |
                RETURN return_list:rl                               {: RETURN = new ReturnStmt(rl); :}
                ;

return_list ::= expr:e                                              {: RETURN = new ReturnList(e); :}
                |
                expr:e COMMA return_list:rl                         {: RETURN = new ReturnList(e, rl); :}
                ;

function_decl ::= IDENTIFIER:id OPEN_PAREN function_param:fp 
                  CLOSE_PAREN return_type:rt block_stmt:bs          {: RETURN = new FunctionDecl(id, fp, rt, bs); :}
                  ;

return_type ::= COLON type_list:tl                                  {: RETURN = new ReturnType(tl); :}
                |  
                ;

type_list ::= type:t                                                {: RETURN = new TypeList(t); :}
              | 
              type:t COMMA type_list:tl                             {: RETURN = new TypeList(t, tl); :}
              ;

function_decl_list ::= function_decl:fd function_decl_list:fdl      {: RETURN = new FunctionDeclList(fd, fdl); :}
            |                       
                                                                    {: RETURN = null; :}
            ;

function_param ::= var_decl:vd                                      {: RETURN = new FunctionParam(vd); :}
                   |
                   var_decl:vd COMMA function_param:fp              {: RETURN = new FunctionParam(vd, fp); :}
                   ;

block_stmt ::= OPEN_BRACE CLOSE_BRACE                               {: RETURN = new BlockStmt(); :}
               |
               OPEN_BRACE stmt_list:sl CLOSE_BRACE                  {: RETURN = new BlockStmt(sl)}
               |
               OPEN_BRACE stmt_list:sl return_stmt:rs CLOSE_BRACE   {: RETURN = new BlockStmt(sl, rm); :}
               ;

stmt_list ::= stmt:s                                                {: RETURN = new StmtList(s); :}
              |
              stmt:s stmt_list:sl                                   {: RETURN = new StmtList(s, sl); :}
              ;

use_id ::= USE IDENTIFIER:id                                        {: RETURN = new UseId(id, false); :}
           |  
           USE IDENTIFIER:id SEMICOLON                              {: RETURN = new UseId{id, true}; :}
           |
           USE IDENTIFIER:id use_id:ui                              {: RETURN = new UseId(id, ui, false)}
           |
           USE IDENTIFIER:id SEMICOLON use_id:ui                    {: RETURN = new UseId(id, ui, true); :}
           ;

program ::= function_decl_list:fdl                                  {: RETURN = new Program(fdl)}
            |
            use_id:useidc function_decl_list:fdl                    {: RETURN = new Program(useidc, fdl); }
            ;
