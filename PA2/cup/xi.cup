// A stub for a Xi CUP specification.

package jl2755;

// You might want to add types to these declarations.
terminal java.lang.String IDENTIFIER;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.Integer INTEGER_LITERAL;
terminal java.lang.Boolean TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, BREAK, RETURN, USE, LENGTH, PLUS, MINUS, TIMES, HIGH_MULT
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE;

// You might want to add types to these declarations.
nonterminal program;
// Add more nonterminals here...
nonterminal var_decl;
nonterminal type;
nonterminal array_decl;
nonterminal array_num_decl;
nonterminal expr;
nonterminal unary;
nonterminal binary;

start with program;

// Recognizes "Hello World!", but not much else.
program ::= USE IDENTIFIER IDENTIFIER OPEN_PAREN IDENTIFIER COLON
  INT OPEN_BRACKET CLOSE_BRACKET OPEN_BRACKET CLOSE_BRACKET CLOSE_PAREN
  OPEN_BRACE IDENTIFIER OPEN_PAREN STRING_LITERAL CLOSE_PAREN CLOSE_BRACE;

var_decl ::= IDENTIFIER COLON type SEMICOLON 
             | 
             IDENTIFIER COLON type GETS expr SEMICOLON 
             | 
             var_decl COMMA var_decl 
             ;

type ::= INT array_decl
         |
         INT array_num_decl
         |
         BOOL array_decl
         |
         BOOL array_num_decl
         ;

array_decl ::= array_num_decl OPEN_BRACKET CLOSE_BRACKET
               |
               array_decl OPEN_BRACKET CLOSE_BRACKET
               |
          
               ;

array_num_decl ::= array_num_decl OPEN_BRACKET INTEGER_LITERAL CLOSE_BRACKET
                   |
              
                   ;

expr ::= unary
         |
         binary
         |
         literal
         |
         IDENTIFIER
         |
         function_call
         |
         array_literal
         |
         OPEN_PAREN expr CLOSE_PAREN
         ;

unary ::= MINUS expr
          |
          NOT expr
          ;

binary ::= expr binary_op expr
           ;

binary_op ::= PLUS | MINUS | TIMES | HIGH_MULT | DIVIDE
              |
              MODULO | LT | LEQ | GT | GEQ
              |
              AND | OR | EQUAL | NOT_EQUAL
              ;

literal ::= INTEGER_LITERAL
            |
            CHARACTER_LITERAL
            |
            STRING_LITERAL
            |
            TRUE | FALSE
            ;

function_call ::= IDENTIFIER OPEN_PAREN function_param CLOSE_PAREN
                  |
                  IDENTIFIER OPEN_PAREN CLOSE_PAREN

function_param ::= expr
                   |
                   expr COMMA function_param
                   ;

array_literal ::= OPEN_BRACE array_base CLOSE_BRACE
				  |
				  

array_base ::= INTEGER_LITERAL array_recursive
			   |
			   INTEGER_LITERAL array_recursive COMMA
			   |
			   ;

array_recursive ::= COMMA INTEGER_LITERAL array_recursive
					|
					;