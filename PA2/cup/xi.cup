// A stub for a Xi CUP specification.

package jl2755;

/* Terminals */
terminal java.lang.String IDENTIFIER;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.Integer INTEGER_LITERAL;
terminal java.lang.Boolean TRUE, FALSE;
// keywords
terminal IF, ELSE, WHILE, RETURN, USE, PLUS, MINUS, TIMES, HIGH_MULT, INT, BOOL,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, LENGTH;

/* Nonterminals */
// You might want to add types to these declarations.
nonterminal program;
// Add more nonterminals here...
nonterminal var_init;
nonterminal var_decl;
nonterminal tuple_init;
nonterminal tuple_decl_list;
nonterminal type;
nonterminal type_list;
nonterminal return_type;
nonterminal primitive_type;
nonterminal array_type;
nonterminal brackets;
nonterminal brackets_with_content;
nonterminal expr;
nonterminal constant;
nonterminal unary_expr;
nonterminal binary_expr;
nonterminal binary_op;
nonterminal literal;
nonterminal use_id;
nonterminal function_param;
nonterminal function_decl;
nonterminal function_decl_list;
nonterminal function_call;
nonterminal function_arg;
nonterminal array_literal;
nonterminal array_element_list;
nonterminal array_element;
nonterminal stmt;
nonterminal assignment_stmt;
nonterminal if_stmt;
nonterminal while_stmt;
nonterminal return_stmt;
nonterminal block_stmt;
nonterminal stmt_list;
nonterminal return_list;


/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL;
precedence left LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS; 
precedence left TIMES, HIGH_MULT, DIVIDE, MODULO;
precedence nonassoc ELSE;     // to avoid "dangling else" problem
// missing integer and logical negation (unary minus vs. binary minus)
precedence left OPEN_BRACKET, OPEN_PAREN;  // missing function call, []


start with program;

/* Grammar */
var_decl ::= IDENTIFIER COLON type {: }
            ;

var_init ::= var_decl GETS expr ;

tuple_init ::= UNDERSCORE tuple_decl_list GETS function_call        {: RESULT = new TupleInit(); :}
           |
           var_decl tuple_decl_list GETS function_call
           |
           UNDERSCORE GETS function_call
           ;

tuple_decl_list ::= COMMA var_decl                                  {: RESULT = new TupleDeclList(var_decl, false); :}
          |
          COMMA var_decl tuple_decl_list                            {: RESULT = new TupleDeclList(); :}
          |
          COMMA UNDERSCORE                                          {: RESULT = new TupleDeclList(); :}
          |
          COMMA UNDERSCORE tuple_decl_list                          {: RESULT = new TupleDeclList(); :}
          ;

type ::= primitive_type 
         | 
         array_type ;

primitive_type ::= INT                                              {: RESULT = new PrimitiveType(0); :}         
                   | 
                   BOOL                                             {: RESULT = new PrimitiveType(1); :}
                   ;

array_type ::= primitive_type brackets                              {: RETURN = new ArrayType(primitive_type, brackets); :}
               |
               primitive_type brackets_with_content                 {: RETURN = new ArrayType(primitive_type, brackets_with_content); :}
               |
               primitive_type brackets_with_content brackets        {: RETURN = new ArrayType(primitive_type, brackets_with_content, brackets); :}
               ;

brackets ::= OPEN_BRACKET CLOSE_BRACKET                             {: RETURN = new Brackets(); :}
             | 
             OPEN_BRACKET CLOSE_BRACKET brackets                    {: RETURN = new Brackets(brackets); :}
             ;

brackets_with_content ::= OPEN_BRACKET expr CLOSE_BRACKET           {: RETURN = new BracketsWithContent(expr); :}
                       |
                       OPEN_BRACKET expr CLOSE_BRACKET brackets_with_content  {: RETURN = new BracketsWithContent(expr, brackets_with_content); :}
                       ;

expr ::= constant
         |
         unary_expr
         |
         binary_expr
         |
         IDENTIFIER
         |
         array_element
         |
         function_call
         |
         OPEN_PAREN expr CLOSE_PAREN
         ;

constant ::= literal | array_literal ;

unary_expr ::= MINUS expr
               |
               NOT expr
               ;

binary_expr ::= expr binary_op expr ;

binary_op ::= PLUS | MINUS | TIMES | HIGH_MULT | DIVIDE | MODULO
              |
              EQUAL | NOT_EQUAL | LT | LEQ | GT | GEQ
              |
              AND | OR
              ;

literal ::= INTEGER_LITERAL
            |
            CHARACTER_LITERAL
            |
            STRING_LITERAL
            |
            TRUE | FALSE
            ;

function_call ::= IDENTIFIER OPEN_PAREN function_arg CLOSE_PAREN
                  |
                  IDENTIFIER OPEN_PAREN CLOSE_PAREN
                  ;

function_arg ::= expr
                 |
                 expr COMMA function_arg
                 ;

array_literal ::= OPEN_BRACE array_element_list CLOSE_BRACE ;

array_element_list ::= expr
                       |
                       expr COMMA array_element_list
                       |
                       ;

array_element ::= IDENTIFIER brackets_with_content ;

stmt ::= naked_stmt SEMICOLON                                       {: RETURN = new Stmt(naked_stmt, true); :}
         |
         naked_stmt                                                 {: RETURN = new Stmt(naked_stmt, false); :}
         ;

naked_stmt ::= assignment_stmt
         |
         if_stmt
         |
         while_stmt
         |
         function_call
         |
         block_stmt
         |
         var_decl | var_init | tuple_init
         ;

assignment_stmt ::= IDENTIFIER GETS expr 
                    |
                    array_element GETS expr
                    ;

if_stmt ::= IF OPEN_PAREN expr CLOSE_PAREN stmt                     {: RETURN = new IfStmt(expr, stmt); :}
            | 
            IF OPEN_PAREN expr CLOSE_PAREN stmt:s1 ELSE stmt:s2     {: RETURN = new IfStmt(expr, s1, s2); :}
            ;

while_stmt ::= WHILE OPEN_PAREN expr CLOSE_PAREN stmt               {: RETURN = new WhileStmt(expr); :}

return_stmt ::= RETURN                                              {: RETURN = new ReturnStmt(); :}
                |
                RETURN return_list                                  {: RETURN = new ReturnStmt(return_list); :}
                ;

return_list ::= expr                                                {: RETURN = new ReturnList(expr); :}
                |
                expr COMMA return_list                              {: RETURN = new ReturnList(expr, return_list); :}
                ;

function_decl ::= IDENTIFIER OPEN_PAREN function_param 
                  CLOSE_PAREN return_type block_stmt                {: RETURN = new FunctionDecl(IDENTIFIER, function_param, return_type, block_stmt); :}
                  ;

return_type ::= COLON type_list                                     {: RETURN = new }
                |  
                ;

type_list ::= type | type COMMA type_list ;

function_decl_list ::= function_decl function_decl_list             
            |                       
            ;

function_param ::= var_decl                                         {: RETURN = new FunctionParam(var_decl); :}
                   |
                   var_decl COMMA function_param                    {: RETURN = new FunctionParam(var_decl, function_param_); :}
                   ;

block_stmt ::= OPEN_BRACE CLOSE_BRACE
               |
               OPEN_BRACE stmt_list CLOSE_BRACE
               |
               OPEN_BRACE stmt_list return_stmt CLOSE_BRACE
               ;

stmt_list ::= stmt
              |
              stmt SEMICOLON
              |
              stmt stmt_list
              |
              stmt SEMICOLON stmt_list
              ;

use_id ::= USE IDENTIFIER
           |  
           USE IDENTIFIER SEMICOLON
           |
           USE IDENTIFIER use_id
           |
           USE IDENTIFIER SEMICOLON use_id
           ;

program ::= function_decl_list
            |
            use_id function_decl_list
            ;
