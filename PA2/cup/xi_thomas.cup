// A stub for a Xi CUP specification.

package jl2755;

/* Terminals */
terminal java.lang.String IDENTIFIER;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.Integer INTEGER_LITERAL;
terminal java.lang.Boolean TRUE, FALSE;
terminal INT, BOOL;

// keywords
terminal IF, ELSE, WHILE, BREAK, RETURN, USE, LENGTH, PLUS, MINUS, TIMES, HIGH_MULT
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE;

/* Nonterminals */
// You might want to add types to these declarations.
nonterminal program;
// Add more nonterminals here...
nonterminal decl;
nonterminal var_decl;
nonterminal var_decl_list;
nonterminal type;
nonterminal primitive_type;
nonterminal array_type;
nonterminal brackets;
nonterminal brackets_with_size;
nonterminal expr;
nonterminal constant;
nonterminal unary_expr;
nonterminal binary_expr;
nonterminal binary_op;
nonterminal function_call;
nonterminal function_param;
nonterminal array_literal;
nonterminal array_element_list;
nonterminal array_element;
nonterminal assignment_stmt;
nonterminal if_stmt;
nonterminal while_stmt;
nonterminal return_stmt;
nonterminal block_stmt;


/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL;
precedence left LT, LEQ, GT, GEQ;
precedence left PLUS, MINUS; 
precedence left TIMES, HIGH_MULT, DIVIDE, MODULO;
precedence left ELSE;     // to avoid "dangling else" problem
// missing integer and logical negation (unary minus vs. binary minus)
// missing function call, []


start with program;

// Recognizes "Hello World!", but not much else.
program ::= USE IDENTIFIER IDENTIFIER OPEN_PAREN IDENTIFIER COLON
  INT OPEN_BRACKET CLOSE_BRACKET OPEN_BRACKET CLOSE_BRACKET CLOSE_PAREN
  OPEN_BRACE IDENTIFIER OPEN_PAREN STRING_LITERAL CLOSE_PAREN CLOSE_BRACE;

decl ::= var_decl | function_decl ;

var_decl ::= IDENTIFIER COLON type ;

var_init ::= var_decl var_decl_list ;

var_decl_list ::= GETS expr
                  |
                  COMMA var_decl
                  |

                  ;

type ::= primitive_type | array_type ;

primitive_type ::= INT | BOOL ;

array_type ::= primitive_type brackets
               |
               primitive_type brackets_with_size
               |
               primitive_type brackets_with_size brackets
               ;

brackets ::= OPEN_BRACKET CLOSE_BRACKET 
             | 
             OPEN_BRACKET CLOSE_BRACKET brackets 
             ;

brackets_with_size ::= OPEN_BRACKET expr CLOSE_BRACKET 
                       |
                       OPEN_BRACKET expr CLOSE_BRACKET brackets_with_size
                       ;

expr ::= constant
         |
         unary_expr
         |
         binary_expr
         |
         IDENTIFIER
         |
         array_element
         |
         function_call
         |
         OPEN_PAREN expr CLOSE_PAREN
         ;

constant ::= literal | array_literal ;

unary_expr ::= MINUS expr
               |
               NOT expr
               ;

binary_expr ::= expr binary_op expr ;

binary_op ::= PLUS | MINUS | TIMES | HIGH_MULT | DIVIDE | MODULO
              |
              LT | LEQ | GT | GEQ
              |
              AND | OR
              ;

literal ::= INTEGER_LITERAL
            |
            CHARACTER_LITERAL
            |
            STRING_LITERAL
            |
            TRUE | FALSE
            ;

function_call ::= IDENTIFIER OPEN_PAREN function_arg CLOSE_PAREN
                  |
                  IDENTIFIER OPEN_PAREN CLOSE_PAREN
                  ;

function_arg ::= expr
                 |
                 expr COMMA function_arg
                 ;

array_literal ::= OPEN_BRACE array_element_list CLOSE_BRACE
                  |
                  OPEN_BRACE CLOSE_BRACE
                  ;

array_element_list ::= constant
                       |
                       constant COMMA array_element_list
                       ;

array_element ::= IDENTIFIER OPEN_BRACKET expr CLOSE_BRACKET ;

stmt ::= assignment_stmt
         |
         if_stmt
         |
         while_stmt
         |
         return_stmt
         |
         function_call
         |
         block_stmt
         |
         var_decl
         ;

assignment_stmt ::= IDENTIFIER EQUAL expr 
                    |
                    array_element EQUAL expr
                    ;

if_stmt ::= IF OPEN_PAREN expr CLOSE_PAREN stmt
            |
            IF OPEN_PAREN expr CLOSE_PAREN ELSE stmt
            ;

while_stmt ::= WHILE OPEN_PAREN expr CLOSE_PAREN stmt ;

return_stmt ::= RETURN return_expr ;

return_expr ::= expr return_expr
                |
                COMMA expr return_expr
                |

                ;

function_decl ::= IDENTIFIER OPEN_PAREN function_param CLOSE_PAREN COLON return_type block_stmt;

function_decl_list ::= function_decl 
                       |
                       function_decl function_decl_list
                       |

                       ;

function_param ::= var_decl
                   |
                   var_decl COMMA function_param 
                   ;

use_id ::= USE IDENTIFIER
           |  
           USE IDENTIFIER use_id;

program ::= function_decl_list
            |
            use_id function_decl_list
            |

            ;

